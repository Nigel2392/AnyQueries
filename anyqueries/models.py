from django.db import models
from django.http import JsonResponse
from django.forms.models import model_to_dict
from django.shortcuts import render
from django.conf import settings
from django.core.cache import cache
from django.core.mail import EmailMultiAlternatives
from django.utils.html import strip_tags
from django.template.loader import get_template
import hashlib
# Generating PDF's
from django.core.files import File
from xhtml2pdf import pisa
import io
# QR codes
import base64
import qrcode
# Querysets
from rest_framework.serializers import ModelSerializer
from shortuuid.django_fields import ShortUUIDField
import datetime

SETTINGS = settings.__dict__['_wrapped'].__dict__
FROM_EMAIL = SETTINGS.get('EMAIL_HOST_USER', 'webmaster@localhost')
KEEP_ORIGINAL_STATE_FOR_MODEL = SETTINGS.get('KEEP_ORIGINAL_STATE_FOR_MODEL', '__all__')

# Exception handling
class MultipleFieldsFound(Exception):
    pass

class NoEmailFieldFound(Exception):
    pass

class CannotSaveFile(Exception):
    pass

class CannotSaveAttribute(Exception):
    pass

class FieldNotAllowed(Exception):
    pass

# Timeout utility class
class Timeout:
    MINUTE = 60
    HOUR = 60 * 60
    DAY = 60 * 60 * 24
    WEEK = 60 * 60 * 24 * 7
    MONTH = 60 * 60 * 24 * 7 * 30
    YEAR = 60 * 60 * 24 * 7 * 30 * 365

    __calculated_time = 0
    __strf_dict = {
        'minute': '%M',
        'hour': '%H',
        'day': '%d',
        'week': '%w',
        'month': '%m',
        'year': '%Y',
    }

    def calc(self, **kwargs):
        timeout = 0
        for key, value in kwargs.items():
            timeout += value * self.__dict__[key]
        self.__calculated_time = timeout
        return self.__calculated_time
    
    def add(self, **kwargs):
        if kwargs == {}:
            return None
        self.__calculated_time += self.calc(**kwargs)
        return self.__calculated_time
    
    def subtract(self, **kwargs):
        if kwargs == {}:
            return None
        self.__calculated_time -= self.calc(**kwargs)
        return self.__calculated_time
    
    def as_time_delta(self, **kwargs) -> datetime.timedelta:
        if self.__calculated_time == 0:
            if not kwargs:
                raise Exception('You must call calc() before as_time_delta(), or provide kwargs')
            self.calc(**kwargs)
        return datetime.timedelta(seconds=self.__calculated_time)
    
    def strftime(self, time_format: str):
        format = time_format.lower()
        for key, value in self.__strf_dict.items():
            format = format.replace(key, value)
        return self.as_time_delta().strftime(format)

# Create your models here.
class AnyQuerySet(models.QuerySet):
    """
    Simple utility based queryset class.
    
    Methods:
    - queryset_from_cache
      ##### - key: str=None, 
      ##### - timeout: int=60, 
      ##### - delete: bool=False

    - get_from_cache
      ##### - delete_cache: bool=False 
      ##### - timeout: int=60 
      ##### - **kwargs -> kwargs to pass to get()

    - clear_cache
      ##### - key: str=None

    - serialize
      ##### - include_fields: list[str]=None
      ##### - readonly_fields: list[str]=None

    - get_model_email_field
        ##### - field_name: str=None (optional)

    - send_mass_email
        ##### - subject
        ##### - template_name
        ##### - message
        ##### - email_field
        ##### - fail_silently
        ##### - kwargs

    - create_prefetch_query

    Attributes:
    - cache_key
    """
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.cache_key = None
        self.model_email_field = None

    @property
    def __generate_key(self) -> str:
        """
        Generate a key based on the query.
        Key is generated by hashing the query. 
        This is to ensure that the key is unique.

        :return: self.cache_key
        """
        key = str(self.query)
        self.cache_key = self.model.__name__ \
            + '_' \
            + self.__hash_key(key)
        return self.cache_key

    @staticmethod
    def __hash_key(key: str) -> str:
        hash_object = hashlib.sha256(key.encode('utf-8'))
        return hash_object.hexdigest()

    def queryset_from_cache(self, key: str=None, timeout: int=Timeout.HOUR, delete: bool=False):
        """
        Append this to any queryset to try to get it from the cache.

        If key is None, we will generate a key based on the query.
        If delete is True, we will delete the cache before filtering.
        If timeout is not None, we will set the timeout for the cache.

        :param key: Key to use for caching.
        :param timeout: Timeout for cache.
        :param delete: Delete cache before getting.
        :return: QuerySet.
        """
        # Generate a key based on the query.
        if key is None:
            # hash the key to be safe.
            key = self.__generate_key
        # If delete is true, the cache will be cleared.
        if delete:
            self.clear_cache(key)
        # If the cache has the key, return the cached object.
        cached_object = cache.get(key, None)
        # If the cache doesn't have the key, create one, and then return the cached object.
        if cached_object is None:
            cached_object = self
            cache.set(key, cached_object, timeout=timeout)
        return cached_object
    
    def get_from_cache(self, delete_cache: bool=False, timeout: int=Timeout.HOUR, **kwargs):
        """
        Get an object.
        If use_cache is true, we will look in the cache for the object.
        If delete_cache is true, we will delete the cache before getting the object.

        :param use_cache: True to use cache, False to not use cache.
        :param delete_cache: True to delete cache, False to not delete cache.
        :param kwargs: Keyword arguments to pass to get().
        :return: Object.
        """
        key = self.__generate_key
        if delete_cache:
            self.clear_cache(key)
        
        cached_object = cache.get(key, None)
        # Cache is empty, set the object.
        if cached_object is None:
            cached_object = super().get(**kwargs)
            cache.set(key, cached_object, timeout=timeout)
        # Return object
        return cached_object

    def clear_cache(self, key: str=None):
        """
        Clear the cache.

        :param key: Key to use for caching.
        :return: QuerySet.
        """
        self.cache_key = None
        if key is None:
            key = self.__generate_key
            
        if cache.has_key(key):
            cache.delete(key)
        return self

    def serialize(self, include_fields: list[str]=None, readonly_fields: list[str]=None):
        """
        Serialize object(s).
        Provides a simple dynamic serializer class.

        :param include_fields: List of fields to include in serialization.
        :param readonly_fields: List of fields to exclude from serialization.

        :return: Serialized object(s).
        """
        class AnySerializer(ModelSerializer):
            class Meta:
                model = self.model
                fields = [field.name for field in self.model._meta.get_fields()] if not include_fields else include_fields
                read_only_fields = ['pk', 'uuid', 'updated_at', 'created_at'] if not readonly_fields else readonly_fields
        return AnySerializer(self, many=True)

    def _get_prefetch_fields(self) -> list[str]:
        """
        Get prefetch fields.

        :return: List of fields to prefetch_related.
        """
        fields = []
        for field in self.model._meta.get_fields():
            if field.one_to_many or field.many_to_many:
                fields.append(field.name)
        return fields

    def _get_select_fields(self) -> list[str]:
        """
        Get select fields.

        :return: List of fields to select_related.
        """
        fields = []
        field = models.Field
        for field in self.model._meta.get_fields():
            if field.one_to_many or field.one_to_one:
                fields.append(field.name)
        return fields

    def create_prefetch_query(self):
        """
        Create an encapsulating prefetch query.
        This will prefetch/select related fields.
        Only works on ManyToManyFields, OneToOneFields, and ForeignKeys defined in the model.
        As of now, it does not work on reverse relations.

        :return: QuerySet.
        """
        self = self.prefetch_related(
                    *self._get_prefetch_fields())\
                .select_related(
                    *self._get_select_fields()
                )
        return self
        
    def get_model_email_field(self, email_field: str=None):
        """
        Check if model has field.
        :param field: Field to check for.
        :return: Field if  has field, False if not.
        """
        if email_field is None:
            fieldlist = []
            # Iterate over all fields in the model, if the field is an email field, add it to the list.
            for field in self.model._meta.get_fields():
                if type(field) is models.EmailField:
                    fieldlist.append(field)
            # Validate that there is only one email field.
            if len(fieldlist) > 1:
                raise MultipleFieldsFound('More than one email field found. Please specify email_field.')
            elif len(fieldlist) > 0:
                self.model_email_field = fieldlist[0]
                return self.model_email_field
            else:
                return False
        else:
            try:
                field = self.model._meta.get_field(email_field)
                if type(field) == models.EmailField():
                    self.model_email_field = field
                    return self.model_email_field
                else:
                    return False
            except Exception as e:
                return False

    def send_mass_email(self, 
                        subject: str, 
                        template_name: str=None, 
                        message: str=None, 
                        email_field: str=None, 
                        fail_silently: bool=False, 
                        **kwargs
        ) -> int:
        """
        Send mass email.
        It's optional, but highly recommended to provide an email_field.

        :param subject: Subject of email.
        :param template_name: Template name of email.
        :param message: Message of email.
        :param email_field: Email field to use.
        :param fail_silently: True to fail silently, False to raise exception.
        :param kwargs: Keyword arguments to pass to send_mail().
        :return: Number of emails sent.
        """
        email_field = self.get_model_email_field(email_field)
        if email_field:
            email_list = list(self.values(email_field.name).distinct())
            SUBJECT = subject
            if template_name is not None:
                HTML = get_template(template_name, kwargs).render(kwargs)
                TEXT = strip_tags(HTML)
                emails = EmailMultiAlternatives(SUBJECT, TEXT, FROM_EMAIL, bcc=email_list)
                emails.attach_alternative(HTML, "text/html")
            else:
                TEXT = message
                emails = EmailMultiAlternatives(SUBJECT, TEXT, FROM_EMAIL, bcc=email_list)
            emails.send(fail_silently=fail_silently)
            return len(email_list)
        else:
            raise NoEmailFieldFound('No email field found.')

class AnyModel(models.Model):
    """
    Basic abstract model class with utility methods.
    Has access to AnyQuerySet by default.

    Starter-fields:
    * id/pk (primary key)
    * created_at (datetime)
    * updated_at (datetime)

    Has utility methods for:
    * as_detail (returns detail of object)
    * generate_pdf (returns PDF of object)
    * generate_qr_code (returns QR code of object)
    * generate_hash (function): Generate hash from string.

    Attributes:
    * object_key (str): Key to use for QR code.
    * to_dict (dict): Dictionary representation of object.
    """
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    uuid = ShortUUIDField(editable=False, max_length=8, alphabet="0123456789abcdefghijklmnopqrstuvwxyz")
    
    # Set default manager to AnyQuerySet for utility functions.
    objects = AnyQuerySet.as_manager()

    EXCLUDE_KEEP_STATE_FIELDS = ['id', 'created_at', 'updated_at', 'uuid']

    class Meta:
        abstract = True

    def __str__(self) -> str:
        """ Return string representation of object. Example: <AnyModel 1> """
        return "{} {}".format(self.__class__.__name__, self.pk)

    def __repr__(self) -> str:
        """ Return dictionary representation of object. """
        return str(self.to_dict)

    @property
    def __KEEP_STATE(self):
        """
        return True if the model's class name is in the KEEP_ORIGINAL_STATE_FOR_MODEL list.
        OR:
        return True if KEEP_ORIGINAL_STATE_FOR_MODEL is equal to "__all__".
        ELSE:
        return False.
        """
        state =\
            self.__class__.__name__ in KEEP_ORIGINAL_STATE_FOR_MODEL\
            or KEEP_ORIGINAL_STATE_FOR_MODEL == "__all__"
        return state

    def __field_is_allowed(self, field: models.Field):
        """
        Check if field is allowed to be kept.
        """
        if field.is_relation \
        or field.name in self.EXCLUDE_KEEP_STATE_FIELDS\
        or field.name in self.DEFERRED_FIELDS:
            return False
        return True

    def __field_has_changed(self, field: models.Field) -> bool:
        """
        Check if field has changed.
        """
        if getattr(self, '__old_%s' % field.name) \
        != getattr(self, field.name):
            return True
        else:
            return False

    def __init__(self, *args, **kwargs):
        """
        Initialize model instance.
        
        Set __old_fields to current state of fields.

        Only works if classname is in settings.KEEP_ORIGINAL_STATE_FOR_MODEL.
            or settings.KEEP_ORIGINAL_STATE_FOR_MODEL == "__all__".
        """
        super().__init__(*args, **kwargs)
        # Check if we want to keep an unmodified copy of the object.
        self.KEEP_STATE = self.__KEEP_STATE
        if self.KEEP_STATE:
            self.DEFERRED_FIELDS = self.get_deferred_fields()
            # If so, create a copy of the object fields.
            for field in self.__safe_fields():
                setattr(self, '__old_%s' % field.name, getattr(self, field.name))
        
    def __safe_fields(self) -> list:
        """
        Yield fields that are allowed to be kept.
        """
        yield from [field for field in self._meta.get_fields() if self.__field_is_allowed(field)]

    def field_has_changed(self, field: str, safe: bool=False) -> bool:
        """
        Check if field has changed.
        """
        _field = self._meta.get_field(field)
        if self.__field_is_allowed(_field) or safe:
            return self.__field_has_changed(_field)
        else:
            raise FieldNotAllowed('Field is related, deferred or excluded, and safe is set to False.')

    @property
    def has_changed(self):
        """
        Check if object has changed. 
         - See __init__ method.
        """
        # Check if we want flag when object has changed.
        # This can be turned on/off in settings.py.
        changed_fields = []
        if self.KEEP_STATE:
            # If so, check if any field has changed.
            for field in self.__safe_fields():
                if self.__field_has_changed(field):
                    changed_fields.append(field.name)
        return changed_fields if changed_fields != [] else False
    
    def generate_hash(self, key: str = None, plain: bool = False) -> str:
        """ Generate hash for object. """
        if key is None:
            key = f'{self.__class__.__name__}_{self.pk}_{self.created_at}'
        if plain:
            return key
        hash = hashlib.sha256(key.encode('utf-8'))
        hex_hash = hash.hexdigest()
        return hex_hash

    @property
    def object_key(self) -> str:
        """ Get key based on object. """
        return f'{self.__class__.__name__}_{self.generate_hash()}'

    @property
    def to_dict(self) -> dict:
        """ Convert object to dict. """
        return model_to_dict(self)

    def get_context_data(self, context_object_name: str="object", **kwargs) -> dict:
        """ Get default context data for detail view. """
        kwargs[context_object_name] = self
        kwargs['model'] = self.__class__.__name__
        kwargs['app_label'] = self._meta.app_label
        return kwargs

    def as_detail(self, template_name: str, request=None, context: dict = None,context_object_name: str="object", json: bool = False):
        """ Return detail of object. """
        if json:
            return JsonResponse(self.to_dict)
        else:
            context = self.get_context_data(**context, context_object_name=context_object_name)
            return render(request, template_name, context)

    def save_to_field(self, save_field, attrib, err=None):
        try:
            setattr(self, save_field, attrib)
            self.save()
        except Exception as e:
            if err is not None:
                raise CannotSaveAttribute(f"{err} {e}")
            else:
                raise CannotSaveAttribute(f"Could not set attribute to field: {save_field}. {e}")

    @staticmethod
    def _create_pdf(html, filename: str = None) -> File:
        """ Create PDF from HTML. """
        result = io.BytesIO()
        pdf = pisa.pisaDocument(html.encode("UTF-8"), result)
        if not pdf.err:
            return File(result, name=filename)
        else:
            return None

    def _get_pdf_template(self, template_path: str, use_cache: bool=True) -> File:
        # Generate a cache key based on the template latter of the template path and the class name.
        pdf_template_cache_key = self.__class__.__name__+'_'+template_path.split('/')[-1]
        # Check if we want to use the cache.
        if use_cache:
            # If so, check if the template is in the cache.
            template = cache.get(pdf_template_cache_key, None)
            if template is None:
                # If not, generate the template and add it to the cache.
                template = get_template(template_path)
                cache.set(pdf_template_cache_key, template, timeout=Timeout.HOUR)
        else:
            # If not, always generate the template.
            template = get_template(template_path)
        return template

    def generate_pdf(self, template_path: str, filename: str, context: dict = {}, context_object_name: str = 'object', use_cache: bool = False, save_field: str = None) -> File:
        """
        Generate a PDF from a specified template.
        Works for single objects.

        :param context: Context to use for template.
        :param template_path: Path to template.
        :param filename: Filename to use for PDF.
        :param context_object_name: Name of object in context.
        :param use_cache: Use cache for PDF.
        :param save_field: Save to field if specified.
            Field must be a FileField.
            Argument must be a string.
        :return: PDF as django.core.files.File object.
        """
        # Set context variable of instance
        context[context_object_name] = self
        # Get template from cache (or optionally, disable cache).
        template = self._get_pdf_template(template_path, use_cache)     

        # If use_cache is True, check cache for PDF.
        if use_cache:
            cache_key = self.generate_hash(key=f"{filename}-{self.pk}")
            pdf = cache.get(cache_key, None)
            if pdf is None:
                # Cache was not hit. Generate PDF and cache it.
                html = template.render(context)

                pdf = self._create_pdf(html, filename)
                cache.set(cache_key, pdf, timeout=Timeout.DAY)
        else:
            # Cache is not used. Generate PDF directly.
            html = template.render(context)

            pdf = self._create_pdf(html, filename)
            if pdf is None:
                raise CannotSaveFile("PDF could not be generated.")
        # Save PDF to field if specified.
        if save_field is not None:
            self.save_to_field(pdf, save_field)
        return pdf

    @staticmethod
    def _create_qr(qr_key: str = None) -> File:
        """ Create QR code from string. """
        # setup the qr code generator
        qr = qrcode.QRCode(
            version=1,
            error_correction=qrcode.constants.ERROR_CORRECT_L,
            box_size=10,
            border=4,
        )
        # Encode the key as BASE64, then add the data to the QR code.
        encoded = base64.encodebytes(bytes(qr_key.encode("utf-8")))
        qr.add_data(encoded)
        # Generate the QR code.
        qr.make(fit=True)
        img = qr.make_image()
        # Save image into a buffer to conver it to
        # a django.core.files.File object.
        buffer = io.BytesIO()
        img.save(buffer, format="PNG")
        return File(buffer, name=f"{qr_key}.png")

    def generate_qr_code(self, qr_key: str = None, use_cache: bool = True, save_field: str = None) -> File:
        """
        Generate QR code for object.

        If qr_key is not specified, uses plaintext hash-key.
            (Format: <class_name>_<id>_<created_at>)
        This is to make fetching models from QR codes easier.

        :param qr_key: Key to use for QR code.
        :param use_cache: Use cache for QR code.
        :param save_field: Save QR code to field if specified. 
            Field must be FileField or ImageField.
            Argument must be a string.
        :return: QR code as django.core.files.File object.
        """
        if qr_key is None:
            qr_key = f"qr_code_{self.pk}_{self.created_at.date()}"
        hashed_key = self.generate_hash(key=qr_key)
        if use_cache:
            qr_code = cache.get(hashed_key, None)
            if qr_code is None:
                qr_code = self._create_qr(qr_key)
                cache.set(hashed_key, qr_code, timeout=Timeout.DAY)
        else:
            qr_code = self._create_qr(qr_key)
        if save_field is not None:
            self.save_to_field(qr_code, save_field)
        return qr_code

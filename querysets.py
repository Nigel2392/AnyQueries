from django.db import models
from django.conf import settings
from django.core.cache import cache
from django.core.mail import EmailMultiAlternatives
from django.utils.html import strip_tags
from django.template.loader import get_template
import hashlib
from rest_framework.serializers import ModelSerializer

class MultipleFieldsFound(Exception):
    pass

class NoEmailFieldFound(Exception):
    pass

class CannotSaveFile(Exception):
    pass

SETTINGS = settings.__dict__['_wrapped'].__dict__
FROM_EMAIL = SETTINGS.get('EMAIL_HOST_USER', 'webmaster@localhost')

# Create your models here.
class AnyQuerySet(models.QuerySet):
    """
    Simple utility based queryset class.
    
    Has options for:
    - caching
    - serialization
    - prefetching
    - mailing

    Methods:
    - queryset_from_cache
      ##### - key: str=None, 
      ##### - timeout: int=60, 
      ##### - delete: bool=False

    - get_from_cache
      ##### - delete_cache: bool=False 
      ##### - timeout: int=60 
      ##### - **kwargs -> kwargs to pass to get()

    - clear_cache
      ##### - key: str=None

    - serialize
      ##### - include_fields: list[str]=None
      ##### - readonly_fields: list[str]=None

    - model_has_email_field
        ##### - field_name: str=None (optional)

    - send_mass_email
        ##### - subject
        ##### - template_name
        ##### - message
        ##### - email_field
        ##### - fail_silently
        ##### - kwargs

    - create_prefetch_query

    Attributes:
    - cache_key
    """
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.cache_key = None
        self.model_email_field = None

    @property
    def __generate_key(self) -> str:
        """
        Generate a key based on the query.
        Key is generated by hashing the query. 
        This is to ensure that the key is unique.

        :return: self.cache_key
        """
        key = str(self.query)
        self.cache_key = self.model.__name__ \
            + '_' \
            + self.__hash_key(key)
        return self.cache_key

    @staticmethod
    def __hash_key(key: str) -> str:
        hash_object = hashlib.sha256(key.encode('utf-8'))
        return hash_object.hexdigest()

    def queryset_from_cache(self, key: str=None, timeout: int=60, delete: bool=False):
        """
        Append this to any queryset to try to get it from the cache.

        If key is None, we will generate a key based on the query.
        If delete is True, we will delete the cache before filtering.
        If timeout is not None, we will set the timeout for the cache.

        :param key: Key to use for caching.
        :param timeout: Timeout for cache.
        :param delete: Delete cache before getting.
        :return: QuerySet.
        """
        # Generate a key based on the query.
        if key is None:
            # hash the key to be safe.
            key = self.__generate_key
        # If delete is true, the cache will be cleared.
        if delete:
            self.clear_cache(key)
        # If the cache has the key, return the cached object.
        cached_object = cache.get(key, None)
        # If the cache doesn't have the key, create one, and then return the cached object.
        if cached_object is None:
            cached_object = self
            cache.set(key, cached_object, timeout=timeout)
        return cached_object
    
    def get_from_cache(self, delete_cache: bool=False, timeout: int=60, **kwargs):
        """
        Get an object.
        If use_cache is true, we will look in the cache for the object.
        If delete_cache is true, we will delete the cache before getting the object.

        :param use_cache: True to use cache, False to not use cache.
        :param delete_cache: True to delete cache, False to not delete cache.
        :param kwargs: Keyword arguments to pass to get().
        :return: Object.
        """
        key = self.__generate_key()
        if delete_cache:
            self.clear_cache(key)
        
        cached_object = cache.get(key, None)
        # Cache is empty, set the object.
        if cached_object is None:
            cached_object = super().get(**kwargs)
            cache.set(key, cached_object, timeout=timeout)
        # Return object
        return cached_object

    def clear_cache(self, key: str=None):
        """
        Clear the cache.

        :param key: Key to use for caching.
        :return: QuerySet.
        """
        self.cache_key = None
        if key is None:
            key = self.__generate_key
            
        if cache.has_key(key):
            cache.delete(key)
        return self

    def serialize(self, include_fields: list[str]=None, readonly_fields: list[str]=None):
        """
        Serialize object(s).
        Provides a simple dynamic serializer class.

        :param include_fields: List of fields to include in serialization.
        :param read_only: List of fields to exclude from serialization.
        :param many: True if many objects, False if one object.

        :return: Serialized object(s).
        """
        class AnySerializer(ModelSerializer):
            class Meta:
                model = self.model
                fields = [field.name for field in self.model._meta.get_fields()] if not include_fields else include_fields
                read_only_fields = ['pk'] if not readonly_fields else readonly_fields
        return AnySerializer(self, many=True)

    def _get_prefetch_fields(self) -> list[str]:
        """
        Get prefetch fields.

        :return: List of fields to prefetch_related.
        """
        fields = []
        for field in self.model._meta.get_fields():
            if type(field) is models.ManyToManyField:
                fields.append(field.name)
        return fields

    def _get_select_fields(self) -> list[str]:
        """
        Get select fields.

        :return: List of fields to select_related.
        """
        fields = []
        for field in self.model._meta.get_fields():
            if type(field) is models.ForeignKey:
                fields.append(field.name)
            elif type(field) is models.OneToOneField:
                fields.append(field.name)
        return fields

    #def from_place(self, place: str="default"):
    #    """
    #    For working with multiple databases.
#
    #    :param place: Place to get objects from.
    #    """
    #    match place:
    #        case 'local':
    #            self.query.using('default')
    #        case 'remote':
    #            self.query.using('remote')
    #        case 'private':
    #            self.query.using('private')
    #        case 'public':
    #            self.query.using('public')
    #        case 'default':
    #            self.query.using('default')
    #    return self
        
    def create_prefetch_query(self):
        """
        Create an encapsulating prefetch query.
        This will prefetch/select related fields.
        Only works on ManyToManyFields, OneToOneFields, and ForeignKeys defined in the model.
        As of now, it does not work on reverse relations.

        :return: QuerySet.
        """
        self = self.prefetch_related(
                    *self._get_prefetch_fields())\
                .select_related(
                    *self._get_select_fields()
                )
        return self
        
    def model_has_email_field(self, email_field: str=None):
        """
        Check if model has field.
        :param field: Field to check for.
        :return: Field if  has field, False if not.
        """
        if email_field is None:
            fieldlist = []
            # Iterate over all fields in the model, if the field is an email field, add it to the list.
            for field in self.model._meta.get_fields():
                if type(field) is models.EmailField:
                    fieldlist.append(field)
            # Validate that there is only one email field.
            if len(fieldlist) > 1:
                raise MultipleFieldsFound('More than one email field found. Please specify email_field.')
            elif len(fieldlist) > 0:
                self.model_email_field = fieldlist[0]
                return self.model_email_field
            else:
                return False
        else:
            try:
                field = self.model._meta.get_field(email_field)
                if type(field) == models.EmailField():
                    self.model_email_field = field
                    return self.model_email_field
                else:
                    return False
            except Exception as e:
                return False

    def send_mass_email(self, 
                        subject: str, 
                        template_name: str=None, 
                        message: str=None, 
                        email_field: str=None, 
                        fail_silently: bool=False, 
                        **kwargs
        ) -> int:
        """
        Send mass email.
        It's optional, but highly recommended to provide an email_field.

        :param subject: Subject of email.
        :param template_name: Template name of email.
        :param message: Message of email.
        :param email_field: Email field to use.
        :param fail_silently: True to fail silently, False to raise exception.
        :param kwargs: Keyword arguments to pass to send_mail().
        :return: Number of emails sent.
        """
        email_field = self.model_has_email_field(email_field)
        if email_field:
            email_list = list(self.values(email_field.name).distinct())
            SUBJECT = subject
            if template_name is not None:
                HTML = get_template(template_name, kwargs).render(kwargs)
                TEXT = strip_tags(HTML)
                emails = EmailMultiAlternatives(SUBJECT, TEXT, FROM_EMAIL, bcc=email_list)
                emails.attach_alternative(HTML, "text/html")
            else:
                TEXT = message
                emails = EmailMultiAlternatives(SUBJECT, TEXT, FROM_EMAIL, bcc=email_list)
            emails.send(fail_silently=fail_silently)
            return len(email_list)
        else:
            raise NoEmailFieldFound('No email field found.')
